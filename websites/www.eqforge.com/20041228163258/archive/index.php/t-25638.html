<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html dir="ltr" lang="en">
<head>
	<title>Civilization Fanatics' Forums - Cumulative Programming Contest</title>
	<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
	<meta name="keywords" content="civilization,civ2,civ3,civ4,civilization iii,civilization ii,civilization iv,downloads,scenarios,modpacks,maps,sid meier,firaxis,strategy,tips,reference" />
	<meta name="description" content="Dedicated to the entire Sid Meier's Civilization series." />
	<link rel="stylesheet" href="http://forums.civfanatics.com/archive/archive.css" />
</head>
<body>
<div class="pagebody">
<div id="navbar"><a href="./">Civilization Fanatics' Forums</a> &gt; <a href="f-3.html">COLOSSEUM</a> &gt; <a href="f-73.html">Computer Talk</a> &gt; Cumulative Programming Contest</div>
<hr />
<div class="pda"><a href="?pda=1">PDA</a></div>
<p class="largefont">View Full Version : <a href="http://forums.civfanatics.com/showthread.php?t=25638">Cumulative Programming Contest</a></p>
<hr />

<div class="post"><div class="posttop"><div class="username">Sirp</div><div class="date">Jun 24, 2002, 04:25 AM</div></div><div class="posttext">I noticed the thread on the computer trivia quiz, and thought it was a good idea - so I'm starting this similiar thread.<br />
<br />
Essentially, we want questions/puzzles that would be difficult for a human to solve by hand, but are conducive to computer-based or programatic solutions. The first person to give the correct answer gets to make the next puzzle. Discussing possible solutions and ideas is encouraged. One doesn't have to use a computer or programming to answer a question, but if the question is well-designed that's probably going to be the easiest way to do it.<br />
<br />
Questions should probably be solvable on a low-end machine. Someone will be considered to have gotten the correct answer if they can post a proof as to why the question is impossible to solve easily, or at all.<br />
<br />
Posters are also encouraged to post solutions to problems in various languages, including perhaps, weird and whacky solutions, terse solutions, and very elegant solutions.<br />
<br />
I'll kick it off with the first problem in my first post.</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Sirp</div><div class="date">Jun 24, 2002, 04:40 AM</div></div><div class="posttext">ok, here is the first puzzle (and yes, I copied the idea for this puzzle from elsewhere...):<br />
<br />
An &quot;addagram&quot; is a sequence of words: beginning with a 3-letter word, one adds a letter, rearranges the 4 letters one now has, to form a new word. Then another letter is added, and the letters are rearranged again to form yet another word.<br />
<br />
For instance:<br />
<br />
mar<br />
mar + c  = cram<br />
cram + h = march<br />
march + s = charms<br />
<br />
and so on.<br />
<br />
The aim of the puzzle is to find the longest possible sequence that can be formed in english.<br />
<br />
If you don't have an electronic dictionary to use as a data set to solve this problem, you can get one from: http://www.itasoftware.com/careers/WORD.LST<br />
<br />
It's just a flat file, one word per line.<br />
<br />
(note that if people use different dictionaries , slightly different results might arise, but I'm sure we can handle that)</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Mechanical_Animal</div><div class="date">Jun 24, 2002, 05:54 AM</div></div><div class="posttext">When creating addagrams, how should the next word be chosen if there are multiple words to create<br />
<br />
eg.<br />
race + t = trace<br />
race + s = races<br />
<br />
should we choose arbitrarily (doesn't matter which one is chosen, as long as one is) or is there a definite rule for which one should be added (for example races would be used since 's' comes before 't').<br />
<br />
Arbitrarily choosing makes it a lot easier to code.<br />
Or should all possibilities be considered???<br />
<br />
Also for those who don't speak english, if you get a words file in your language, you can still participate.  Your results however will be different.</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Sirp</div><div class="date">Jun 24, 2002, 06:40 AM</div></div><div class="posttext">Sorry, maybe I didn't explain it well enough. You can choose any addagram sequence you like. So if there are multiple possible words, you can choose whichever one you like.<br />
<br />
Also, people can use non-english dictionaries if they want, although they are encouraged to use the dictionary to which a reference was posted. (they could perhaps develop their solution using a dictionary in their native language, but then switch over to use the referenced dictionary with their final solution so that they can compare their solution with others).</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Mechanical_Animal</div><div class="date">Jun 24, 2002, 11:21 PM</div></div><div class="posttext">The problem is solveable, however from what's happened to me already finding a solution will probably take a large amount of time.<br />
<br />
An easier and quicker sub problem might be to find all the possible words that can be created by adding one letter to an existing word.<br />
eg. given car the program would find<br />
car + b = crab<br />
car + d = card<br />
car + e = acre<br />
car + e = care<br />
car + e = race<br />
<br />
If you can't solve the problem or its taking too long, try this one.</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Sirp</div><div class="date">Jun 24, 2002, 11:55 PM</div></div><div class="posttext">The problem seems pretty hard at first, but once you think about it for a while, you'll probably be able to work out an answer without too much trouble. (depending upon your programming experience, aptitude for this kind of thing, and so forth :) )<br />
<br />
I have a solution to it written in about 50 lines of C++.<br />
<br />
hmm...perhaps I should have started things off with a slightly easier question...I'll post an easier problem if there are no promising looking answers to this one anytime soon.</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Lovro</div><div class="date">Jun 25, 2002, 03:44 PM</div></div><div class="posttext">Off the top of my head...<br />
<br />
 Since we're dealing with anagrams, sort each word independently of each other in increasing alphabetic order (thus, &quot;march&quot; becomes &quot;archm&quot;).<br />
 Next, sort all the words in alphabetically increasing order<br />
 The solution is the longest sequence of words such that the i-th word is the prefix of the i+1th word, and the i+1th word is exactly one character longer than the i-th word.Now for the complexity.<br />
<br />
 Sorting every word will symptotically be fastest done in quadratic time using insertion sort<br />
 Sorting the entire file will be easiest done using quicksort with strcmp<br />
 Finding the actual longest sequence can be done in time linear to the number of words in the fileJust coded this, and it says '18' for the dictionary you supplied, Sirp. Is this correct?<br />
<br />
EDIT: This algorithm is wrong. :D While it solves another problem efficiently, it does not solve this one at all.</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Sirp</div><div class="date">Jun 25, 2002, 04:23 PM</div></div><div class="posttext">Lovro: I'm afraid I'm at work at the moment, and don't have my result to check against. Anyhow, the aim of the puzzle was to give the complete addagram sequence, not just tell us how long it is! :)<br />
<br />
I'd imagine that'd be a little more work, but not too much...<br />
<br />
anyhow, your solution is sound...</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Lovro</div><div class="date">Jun 26, 2002, 11:13 AM</div></div><div class="posttext">Anyway, I noticed my solution was wrong anyway (misread the problem description), but making another one should not be hard. <br />
<br />
EDIT: The maximum sequence I found is of length 11 and consists of the following words: <br />
<br />
no<br />
nor<br />
nori<br />
irone<br />
orient<br />
orients<br />
serotine<br />
stereoing<br />
estrogenic<br />
egocentrism<br />
egocentrisms<br />
<br />
Is this correct (the length, the sequence itself needs not be unique)?</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Sirp</div><div class="date">Jun 27, 2002, 04:58 AM</div></div><div class="posttext">Lovro:<br />
<br />
I got a longer sequence than you for my answer. It is:<br />
<br />
inn<br />
nine<br />
inane<br />
eonian<br />
enation<br />
sonatine<br />
antinoise<br />
antinomies<br />
nitrosamine<br />
terminations<br />
antimodernist<br />
determinations<br />
intermediations<br />
indeterminations<br />
<br />
I would like to know why we got different answers though :) your proposed solution did seem sound; and I think mine is too.<br />
<br />
I have attached the source code to my solution (in C++) if you're interested. I used a slightly different approach in that I started with the largest words, and tried to find a sequence backwards, as I reasoned that it would be faster this way.<br />
<br />
You can post the next puzzle, since you're the only one to come up with anything looking like a solution...</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Lovro</div><div class="date">Jun 28, 2002, 12:06 AM</div></div><div class="posttext">Oh, yet again did I not solve the correct problem. My solution (the sequence of 11 words) works so that you rearrange the current word and then add an arbitrary latter to the end of the rearranged word to form another word... The algorithm that generates this solution also goes from the last word in a dynamic way.<br />
<br />
Well, good enough for me. :)<br />
<br />
I will be posting the next question later today.</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Lovro</div><div class="date">Jun 28, 2002, 02:03 PM</div></div><div class="posttext">This problem is somewhat easier than the previous, as you will see below. It also has more of an educational feeling to it.<br />
<br />
-----------------------------------<br />
Given a natural number N as input, generate all quadruples of natural numbers smaller than or equal to (&lt;=) N such that <br />
  <br />
  A^2 + B^2 + C^2 = D^2<br />
<br />
Some of these include (1, 2, 2, 3), (1, 4, 8, 9) and (2, 3, 6, 7).<br />
<br />
In this problem, you only need to enumerate all such quadruples, not output all of them. <br />
<br />
Sequences such as (1, 2, 2, 3) and (2, 1, 2, 3) should only be counted once, i.e. all triplets (A, B, C) need to be unique.<br />
<br />
For example, there is only one such quadruple when N=5, and six when N=10.<br />
-----------------------------------<br />
<br />
I will be absent and not able to validate any solutions, I recommend you try and see how large of an N your program can solve the problem for in reasonable time (say, less than ten seconds). The person (other than Sirp) with the largest N (best algorithm) wins. :D<br />
<br />
To check the correctness of your program, see http://www.civfanatics.net/uploads/problem2_solution.txt. This textfile also outlines four different methods of solving, each faster than the previous one and shows how each one evolves from the previous ones.</div></div><hr />


<div class="post"><div class="posttop"><div class="username">ainwood</div><div class="date">Jul 01, 2002, 06:22 AM</div></div><div class="posttext">I haven't had a (serious) try at this yet, but a couple of observations:<br />
<br />
1.)  From the sample code, calculating (A*A + B*B + C*C)  in the inner-most loop is inefficient.  You should calculate A*A and store it for each A iteration; ditto for B*B and C*C.  Then just compare the sums each term.  You can go further, by storing SqrA + SqrB for each iteration etc.<br />
<br />
2.)  Noting the point that A&lt;=B&lt;=C, there is no point in iterating for any A² &gt; N²/3<br />
<br />
3.)  In assessing the algorithms &quot;Efficiency&quot;, how do you assess them on comparitive programming languages / platforms?</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Sirp</div><div class="date">Jul 01, 2002, 04:17 PM</div></div><div class="posttext">ainwood: algorithms are easily compared independently of language and platform. Essentially, in most cases the important thing about an algorithm is its performance when the input data becomes very large. Does it take the same amount of time, independent of how much input data there is? Does it increase in time linearly? Exponentially?<br />
<br />
What's generally used to assess how efficient an algorithm is is generally known as &quot;O-notation&quot;. We say an algorithm is O(n) if it increases linearly when the data set becomes large. It's O(log(n)) if it increases logarithmically, and so forth. Do a search on google for it, and you will find plenty of far more detailed explanations.</div></div><hr />


<div class="post"><div class="posttop"><div class="username">gonzo_for_civ</div><div class="date">Jul 15, 2002, 12:03 AM</div></div><div class="posttext">This thread has not received replies in many days so I am going to un-sticky it. It will remain in this forum and open though so don't take this as a thread closure.</div></div><hr />

<div id="copyright">vBulletin v3.0.3, Copyright &copy;2000-2004, Jelsoft Enterprises Ltd.</div>
</div>
</body>
</html>